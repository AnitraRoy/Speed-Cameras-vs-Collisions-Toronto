# -*- coding: utf-8 -*-
"""Spatial Point Analysis.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1xRZjGmdm0_B6VELrSECtaXpxMs3bYAB_
"""

from google.colab import drive
drive.mount('/content/drive')

import pandas as pd
collisions = pd.read_csv("/content/drive/My Drive/UofT/Third Year/Fall/MIE368 Project - Group 15/Code/collisions_dataset/collisions_enriched.csv")
speed_cameras = pd.read_csv("/content/drive/My Drive/UofT/Third Year/Fall/MIE368 Project - Group 15/Code/speed_camera_dataset/speed_cameras_clean.csv")

!pip install haversine folium

import geopandas as gpd
import numpy as np
from sklearn.cluster import DBSCAN
import folium
from folium.plugins import MarkerCluster, HeatMap
from sklearn.cluster import DBSCAN
from haversine import haversine

#create GeoDataFrames
collisions_gdf = gpd.GeoDataFrame(
    collisions,
    geometry=gpd.points_from_xy(collisions['lon'], collisions['lat']),
    crs="EPSG:4326"  # WGS84 Latitude/Longitude
)

cameras_gdf = gpd.GeoDataFrame(
    speed_cameras,
    geometry=gpd.points_from_xy(speed_cameras['lon'], speed_cameras['lat']),
    crs="EPSG:4326"
)

# convert to UTM for accurate distance calculations
collisions_utm = collisions_gdf.to_crs(epsg=32617)
cameras_utm = cameras_gdf.to_crs(epsg=32617)

buffer_radius = 500  # meters
cameras_utm['buffer'] = cameras_utm.geometry.buffer(buffer_radius)
all_buffers = cameras_utm['buffer'].unary_union

collisions_utm['within_camera_zone'] = collisions_utm.geometry.within(all_buffers)

# DBSCAN clustering
coords = np.array(list(zip(collisions_utm.geometry.x, collisions_utm.geometry.y)))
db = DBSCAN(eps=300, min_samples=5).fit(coords)  # eps=300m, min 5 collisions
collisions_utm['cluster'] = db.labels_

# find nearest camera distance
camera_coords = np.array(list(zip(cameras_utm.geometry.x, cameras_utm.geometry.y)))
collision_coords = np.array(list(zip(collisions_utm.geometry.x, collisions_utm.geometry.y)))

from scipy.spatial import cKDTree
tree = cKDTree(camera_coords)
distances, _ = tree.query(collision_coords, k=1)
collisions_utm['distance_to_camera_m'] = distances

# onvert back to lat/lon for mapping
collisions_map = collisions_utm.to_crs(epsg=4326)
cameras_map = cameras_utm.to_crs(epsg=4326)

import matplotlib.cm as cm
import matplotlib.colors as colors

max_points = 15000
if len(collisions_map) > max_points:
    collisions_sampled = collisions_map.sample(max_points, random_state=42)
else:
    collisions_sampled = collisions_map.copy()

m = folium.Map(
    location=[collisions_sampled['lat'].mean(), collisions_sampled['lon'].mean()],
    zoom_start=12
)

# camera buffer zones (blue circles)
for _, row in cameras_map.iterrows():
    folium.Circle(
        location=[row['lat'], row['lon']],
        radius=buffer_radius,
        color='blue',
        fill=False,
        weight=1,
        popup="Camera Buffer"
    ).add_to(m)

# camera locations (blue markers)
for _, row in cameras_map.iterrows():
    folium.Marker(
        location=[row['lat'], row['lon']],
        icon=folium.Icon(color='blue', icon='camera', prefix='fa')
    ).add_to(m)

# color gradient based on distance to nearest camera
max_vis_distance = 500
norm = colors.Normalize(vmin=0, vmax=max_vis_distance)
cmap = cm.get_cmap('RdYlGn') # gradient: red (within 250m) to yellow (250m to 500m) to green (outside radius) based on distance

# clustered collisions for performance
collision_cluster = MarkerCluster(name="Collisions").add_to(m)

for _, row in collisions_sampled.iterrows():
    color_rgb = cmap(norm(row['distance_to_camera_m']))[:3]
    color_hex = colors.to_hex(color_rgb)

    popup_text = f"""
    Within Camera Zone: {row['within_camera_zone']}<br>
    Distance to Nearest Camera (m): {row['distance_to_camera_m']:.1f}
    """

    folium.CircleMarker(
        location=[row['lat'], row['lon']],
        radius=3,
        color=color_hex,
        fill=True,
        fill_color=color_hex,
        fill_opacity=0.7,
        popup=popup_text
    ).add_to(collision_cluster)

m.save("/content/drive/My Drive/UofT/Third Year/Fall/MIE368 Project - Group 15/Code/camera_coverage_map.html")

m